from __future__ import division
import numpy as npy
from numpy import pi, sin, cos, tan, log10
from scipy import integrate
from scipy import optimize
from plot3d import writePlot2D, writeLaballiur, writePlot3D, writePlot3Dxz, writeOVERFLOW
from grm import writeGRM
from vtk import writeVTK
from fec import writeFEC
from gmsh import writeGMSH
from ebg import writeEBG
from geo import writeGEO

#import pylab as pyl


#-----------------------------------------------------------
# writes BC information for FUN3D
def writeNMF(fname, X, nLE, nWK, nWB, nr, sym):

    ni, nj = X.shape; nk = 2

    # NMF file expects all comments and extra empty lines

    f = open(fname, 'w')
    f.write('# ===== Neutral Map File generated by Python  =====\n')
    f.write('# =================================================\n')
    f.write('# Block# IDIM JDIM KDIM\n')
    f.write('# -------------------------------------------------\n')
    f.write('1\n\n')
    f.write('1 ' + str(ni) + ' ' + str(nj) + ' ' + str(nk) + '\n\n')
    f.write('# =================================================\n')
    f.write('# Type         B1 F1 S1 E1 S2 E2 B2 F2 S1 E1 S2 E2 Swap\n')
    f.write('# ---------------------------------------------------\n')
    f.write("'symmetry_" + sym + "'    1 1   1 " + str(ni) + " 1 " +str(nj) + "\n")
    f.write("'symmetry_" + sym + "'    1 2   1 " + str(ni) + " 1 " +str(nj) + "\n")
    f.write("'one-to-one'    1 5   1 " + str(nk) + " 1 " +str(nWK) + "  1 5  1 " + str(nk) + " " + str(ni) + " " + str(nWK+nLE-1) +" False\n")
    f.write("'viscous_solid' 1 5   1 " + str(nk) + " " + str(nWK) + " " + str(nWK+nLE-1) + "\n")
    f.write("'farfield_riem' 1 6   1 " + str(nk) + " 1 " +str(ni) + "\n");
    f.write("'farfield_riem' 1 3   1 " + str(nj) + " 1 " +str(nk) + "\n");
    f.write("'farfield_riem' 1 4   1 " + str(nj) + " 1 " +str(nk) + "\n");


#-----------------------------------
def Distance(i, dx_te, ratio):
    return dx_te*(ratio**i - 1) / (ratio-1)

def GradDist(i, dx_te, ratio):
    return dx_te*((i-1)*ratio**i - i*ratio**(i-1) + 1) / (ratio-1)**2


def FindStretching(n, h_min, Hc):
    # Find the ratio of successive cell sizes to get a total length of Hc from
    # n cells, starting with the first cell size = h_min.
    
    # This guess is exact for very large size ratios
    guess = (Hc / h_min)**(1/(n-1))
    finished = False
    while not finished:
        func = Distance(n, h_min, guess) - Hc
        grad = GradDist(n, h_min, guess)
        delta = - func / grad
        guess += delta
        #print guess, ' ', delta
        if (abs(delta) < 1.e-12):
            finished = True

    return guess;
    

#-----------------------------------
def tanh(i, nn, delta):
    return 1 + npy.tanh(delta*(i/nn - 1))/npy.tanh(delta)

def dtanhddelta(i, nn, delta):
    return (-1 + i/nn)/(npy.tanh(delta) * npy.cosh(delta* (-1 + i/nn))**2) - npy.tanh(delta* (-1 + i/nn))/(npy.sinh(delta)**2)

def find_tanh_delta( ds, nn ):
    
    guess = 2
    itmax = 1000
    it = 0
    finished = False
    while not finished and it < itmax:
        func = tanh(1, nn, guess) - ds
        grad = dtanhddelta(1, nn, guess)
        delta = - func / grad
        guess += delta
        it = it + 1
        #print guess, ' ', delta
        if (abs(delta) < 1e-12):
            finished = True
    
    #if it == itmax:
    #    assert(it < itmax)
    return guess

def coarsen(re, ref, maxref):
    i = maxref
    while i > ref:
        re = npy.delete(re, npy.s_[1::2], 0 )
        i = i-1
    return re

#-----------------------------------
def Bezier(nn, smax=1, ds0=-0.2, ds1=-0.2):

    s0 = npy.linspace(0,smax,nn+1)
    
    #Use a Bezier curve to cluster at LE and TE: ds = -1 gives a linear distribution. Clustering is added as ds->0 from -1
    #ds0 = -0.2
    #ds1 = -0.2
    P0 = 1
    P1 = (3 + ds1)/3
    P2 = -(ds0/3)
    s1 = P0*(1 - s0)**3 + P1*3*s0*(1 - s0)**2 + P2*3*s0**2*(1 - s0)
    return s1

#-----------------------------------
def Cos(nn, smax=1):
    s0 = npy.linspace(0,smax,nn+1)
    return 1-0.5*(1-npy.cos(pi*s0))

#-----------------------------------
def Joukowski_wake_x(nchordwise, nn, Hc, ds1 = -0.2):
    
    frac = 2
    nAf = int(nchordwise/frac)
    a = 0.1
    #s = 1-npy.linspace(0,1/frac,nAf+1)
    #s = Cos(nAf,1/frac)
    s = Bezier(nAf,1/frac,ds1=ds1)
    den  = 1 + 2*a*(1 + a)*(1 + cos(pi*s)) ;
    xnum = (1 + a*(1 + 2*a)*(1 + cos(pi*s)))*(sin(0.5*pi*s))**2 ;
    x = 1-xnum/den;
 
    #for i in xrange(7,nn+1):
    #    x[i] = (i-6)*x[i]
    
    #x = x/x[-1]
    
    nWake = nn-nAf
    dx = x[-1] - x[-2]
    
    re = npy.zeros(nn+1)
    re[0:nAf+1] = x
    ratio = FindStretching(nWake, dx, Hc-x[-1])
    for i in xrange(nWake+1):
        re[nAf+i] = x[-1] + Distance(i, dx, ratio)
    
    return re/Hc

def make_airfoil(ref, Q, TriFlag, FileFormat, reynolds=1.e6, filename_base="Joukowski"):
    #
    # Makes a quad or tri grid for an airfoil. This file must have two numbers
    # per line, each representing an (x,y) coordinate of a point.
    # The points should start at the trailing edge and loop clockwise.  
    # The trailing-edge is assumed closed (no gap), and the trailing-
    # edge point should not be repeated.  The number of points in
    # the file should be sufficient to represent the geometry well, but
    # it need not be a multiple of Q as the points will be re-splined.
    # An optional hard-coded analytical geometry function can be used to
    # nudge points to the true geometry (if using the spline is not enough).
    # The spacing of points on the geometry is done via a quasi-curvature
    # based method -- the optional pg2d size input controls this.
    # The generated pg2d is of the "C" type (see graphic make_airfoil.png).
    #
    # INPUTS:
    #   ref        : refinement number (useful for convergence studies)
    #   Q          : geometry order (e.g. 1,2,3,4,...)
    #   TriFlag    : False = quad, True = tri
    #   FileFormat : String file format switch
    #   reynolds   : Switch for choosing grid spacings
    #   filename_base : File name base for dump
    #
    
    maxref = 6
    assert( ref <= maxref )
    Dfarfield = 100    # farfield distance from the airfoil
    farang=0.0
    nchordwise=8       # number of elements along one side of the airfoil geometry
    nxwake=8           # x-wake on centerline
    nnormal=16         # points normal to airfoil surface
    wakeangle=0.0      # angle of wake leaving the airfoil
    rxwakefary = 0.35  # x-wake stretching far from airfoil (+/-y)
    
    # Trailing edge spacing
    if (reynolds > 5e5):
        # Turbulent. 
        ds1 = -0.1
    else:
        # Laminar.  
        ds1 = -0.2
    
    #--------------------#
    # load/spline points #
    #--------------------#
    X, saf = Joukowski(nchordwise*2**ref,Q,ds1) #Don't use the max refinement to make sure the high-order nodes are distributted well
    
    c = max(X[:,0]) - min(X[:,0])          # chord length
    Hc = Dfarfield*c                       # farfield distance
    
    xte = X[0,:];                          # TE point
    dx_te = X[0,0] - X[Q,0];
    XLE = X[npy.append(range(len(X)),0),:] # rest of airfoil
    nLE = len(XLE)

    #-------------------------------------#
    # put points down along farfield, FLE #
    #-------------------------------------#
    x0     = tan(farang)*Hc
    radius = (x0**2 + Hc**2)**0.5
    t0 = npy.linspace( 3.*pi/2., 5.*pi/2., nLE)

    FLE    = npy.zeros([nLE,2])
    FLE[:,0] = x0 - radius*cos(t0)
    FLE[:,1] =      radius*sin(t0)

    #pyl.plot(FLE[:,0],FLE[:,1],'o')
    #pyl.show()
    
    #----------------------#
    # x-wake on centerline #
    #----------------------#
    nr0 = nxwake*2**maxref 

    re = Joukowski_wake_x(nchordwise*2**maxref, nr0, Hc)

    re = coarsen(re, ref, maxref)
    rw = spaceq(re, Q)
    
    #----------------------------------#
    # C-grid: put points on wake first #
    #----------------------------------#
    
    XWK = npy.flipud(npy.array([rw*Hc+xte[0], npy.zeros(len(rw))]).transpose())
    XWK[:,1] = (XWK[:,0]-xte[0])*tan(wakeangle)
    XWK2 = npy.flipud(XWK)

    nWK = len(XWK)
    
    #----------------------------------------#
    # x-wake spacing far from airfoil (+/-y) #
    #----------------------------------------#
    a  = 0.1
    b  = rxwakefary
    re = (npy.logspace(a,b,nr0+1) - 10**a)/(10**b-10**a)
    re = coarsen(re, ref, maxref)
    rbot = npy.flipud(spaceq(re, Q)*(Hc+xte[0]))
    
    FWK1 = npy.array([rbot,              XWK[:,1] - Hc - rbot*x0/Hc]).transpose()
    FWK2 = npy.array([npy.flipud(rbot), XWK2[:,1] + Hc + npy.flipud(rbot)*x0/Hc]).transpose()
    
    #-------------------#
    # Wake and boundary #
    #-------------------#
    XWB = npy.append(XWK,  XLE[1:-1,:], axis = 0)
    XWB = npy.append(XWB,  XWK2,        axis = 0)
    FWB = npy.append(FWK1, FLE[1:-1,:], axis = 0)
    FWB = npy.append(FWB,  FWK2,        axis = 0)
    
    nWB = len(XWB)
    
    #------------------#
    # points on C grid #
    #------------------#
    nr0 = nnormal*2**ref
    nr = 1 + nr0*Q
    XC = npy.zeros([nWB, nr])
    YC = npy.array(XC)


    # Spacing estations
    if (reynolds > 5e5):
        # Turbulent.  y+=1 for the first cell at the TE on the coarse pg2d
        coarse_yplus = 80
        dy_te = 5.82 * (coarse_yplus / reynolds**0.9) / 2**maxref
        wake_power = 0.8
        
        nr0 = nnormal*2**maxref
        re = npy.zeros(nr0+1)
        #delta = find_tanh_delta( dy_te/Hc, nr0 )
        #for i2 in xrange(0, nr0+1):
        #    re[i2] = tanh(i2, nr0, delta)
        ratio = FindStretching(nr0, dy_te, Hc)
        for i2 in xrange(0, nr0+1):
            re[i2] = Distance(i2, dy_te, ratio)/Hc

    else:
        # Laminar.  Put two cells across the BL at the TE on the coarse mesh
        dy_te = 0.1 / reynolds**0.5 / 2**maxref
        wake_power = 0.5
        
        nr0 = nnormal*2**maxref
        re = Joukowski_wake_x(nchordwise*2**maxref, nr0, Hc, ds1)

    #print "dy_te = ", dy_te, re[1]*Hc

    re = coarsen(re, ref, maxref)
    r0 = spaceq(re, Q)

    for i in xrange(nWB):
        #iplus = min(nWB-1, i+1)
        #iminus = max(0, i-1)
        #ds = ((XWB[iplus,0] - XWB[iminus,0])**2 +
        #      (XWB[iplus,1] - XWB[iminus,1])**2)**0.5/ (iplus - iminus)
              
        #dy = dy_te * max(XWB[i,0],1)**wake_power
        # print XWB[iplus,0], XWB[iminus,0], ds, dy, iplus, iminus
        #re = npy.zeros(nr0+1)
        #ratio = FindStretching(nr0, dy, Hc)
        #for i2 in xrange(0, nr0+1):
            #print i2, Distance(i2, dy, ratio)/Hc
        #    re[i2] = Distance(i2, dy, ratio)/Hc
            
        #delta = find_tanh_delta( dy/Hc, nr0 )
        #for i2 in xrange(0, nr0+1):
        #    re[i2] = tanh(i2, nr0, delta)

        #re = coarsen(re, ref, maxref)
        #r0 = spaceq(re, Q)
        #print re
    
        r = r0
        #if i < nWK-1 or i > nWB-nWK-1:
        #    xx = (XWB[i,0]-XWK[-1,0])/max(XWB[:,0])
        #    r = r0 * (1-xx) + r1 * xx
        XC[i,:] = XWB[i,0] + r*(FWB[i,0]-XWB[i,0])
        YC[i,:] = XWB[i,1] + r*(FWB[i,1]-XWB[i,1])
    
    assert(XC.shape[0] == nWB)
    assert(XC.shape[1] == nr)

    fac = 2 if TriFlag else 1
    print 'Cell size ' + str( int((nWB-1)/Q) ) + 'x' + str( int((nr-1)/Q) ) + ' with '  + str( fac*int((nWB-1)/Q)*int((nr-1)/Q) ) + ' Elements'
    
    if FileFormat == 'p2d':
        writePlot2D(filename_base + '_ref'+str(ref)+ '_Q'+str(Q)+'.p2d.x', XC, YC)
    if FileFormat == 'labl':
        assert Q == 1
        writeLaballiur(filename_base + '_ref'+str(ref)+ '_Q'+str(Q)+'.labl', XC, YC, nWK)
    if FileFormat == 'p3dxy':
        writeNMF(filename_base + '_ref'+str(ref)+ '_Q'+str(Q)+'.nmf', XC, nLE, nWK, nWB, nr, 'z')
        writePlot3D(filename_base + '_ref'+str(ref)+ '_Q'+str(Q)+'.p3d', XC, YC)
    if FileFormat == 'p3dxz':
        writeNMF(filename_base + '_ref'+str(ref)+ '_Q'+str(Q)+'.nmf', XC, nLE, nWK, nWB, nr, 'y')
        writePlot3Dxz(filename_base + '_ref'+str(ref)+ '_Q'+str(Q)+'.p3d', XC, YC)
    if FileFormat == 'in':
        writeOVERFLOW('grid.in.'+str(ref), XC, YC)
    if FileFormat == 'hypgen':
        print "Normal spacing: ", "{:3.16e}".format(dx_te)
        writePlot2D('joukowski_c.crv', XC[:,0:1], YC[:,0:1])
    if FileFormat == 'ebg':
        writeEBG('joukowski.ebg', XC, YC, nWK)
    if FileFormat == 'geo':
        writeGEO('joukowski.geo', XC, YC, nWK)
         
    
    #--------------------#
    # Vertices, unrolled #
    #--------------------#
    V = npy.zeros((nWB*nr,2),float)
    V[:,0] = XC.T.reshape(nWB*nr)
    V[:,1] = YC.T.reshape(nWB*nr)
    
    #pyl.plot(XC.reshape(nWB*nr),YC.reshape(nWB*nr),'o')
    #pyl.show()

    #pyl.plot(V[:,0],V[:,1],'o')
    #pyl.show()

    #---------------------------------------------#
    # node number matrices for writing out blocks #
    #---------------------------------------------#

    NC = npy.arange(nWB*nr).reshape( (nr, nWB) ).T+1
    V = npy.delete(V,NC[nWB-nWK:nWB,0]-1,0)
    NC[nWB-nWK:nWB,0] = NC[nWK-1::-1,0]
    NC[:,1:] = NC[:,1:]-nWK
    
    #---------------#
    # form elements #
    #---------------#
    E = block_elem(NC, Q);

    #---------------#
    # write file    #
    #---------------#

    if FileFormat == 'grm':
        writeGRM(filename_base, ref, Q, TriFlag, E, V, nLE, NC, nWK, nWB, nr);
    if FileFormat == 'fec':
        writeVTK(filename_base, ref, Q, E, V);
        writeFEC(filename_base, ref, Q, E, V, nLE, NC, nWK, nWB, nr);
    if FileFormat == 'msh':
        writeGMSH(filename_base, ref, Q, TriFlag, E, V, nLE, NC, nWK, nWB, nr);

    print("Done with refinement " + str(ref))
    
#-----------------------------------
def block_elem(N, Q):
    nx, ny = N.shape;
    #if (Q != 1) and ((mod(nx,Q) != 1) or (mod(ny,Q) != 1)): print('ERROR 2'); return;
    mx = int((nx-1)/Q);
    my = int((ny-1)/Q);
    E = npy.zeros( (mx*my,(Q+1)*(Q+1)),int);
    i = 0;
    for imy in xrange(my):
        for imx in xrange(mx):
            ix = Q*(imx+1)-(Q-1)-1;
            iy = Q*(imy+1)-(Q-1)-1;
            k = 0;
            for ky in xrange(Q+1):
                for kx in xrange(Q+1):
                    E[i,k] = N[ix+kx,iy+ky]
                    k = k+1;

            i = i + 1;
      
    return E



#-----------------------------------
def Joukowski_xy(s,a):
    den  = 1 + 2*a*(1 + a)*(1 + cos(pi*s)) ;
    xnum = (1 + a*(1 + 2*a)*(1 + cos(pi*s)))*(sin(0.5*pi*s))**2 ;
    ynum = 0.5*a*(1 + 2*a)*(1 + cos(pi*s))*sin(pi*s) ;
    x = xnum/den ;
    y = ynum/den ;
    
    return x, y

#-----------------------------------
def Joukowski_dxy_ds(s,a):
    den  = 1 + 2*a*(1 + a)*(1 + cos(pi*s)) ;
    xnum = (1 + a*(1 + 2*a)*(1 + cos(pi*s)))*(sin(0.5*pi*s))**2 ;
    ynum = 0.5*a*(1 + 2*a)*(1 + cos(pi*s))*sin(pi*s) ;

    den_ds  = -2*a*(1 + a)*pi*sin(pi*s) ;
    xnum_ds = pi*cos((pi*s)/2.)*(1 + a*(1 + 2*a)*(1 + cos(pi*s)))*sin((pi*s)/2.) - a*(1 + 2*a)*pi*sin((pi*s)/2.)**2*sin(pi*s) ;
    ynum_ds = (a*(1 + 2*a)*pi*cos(pi*s)*(1 + cos(pi*s)))/2. - (a*(1 + 2*a)*pi*sin(pi*s)**2)/2. ;

    dxds = xnum_ds/den - xnum*den_ds/den**2 ;
    dyds = ynum_ds/den - ynum*den_ds/den**2 ;
    
    return dxds, dyds

#-----------------------------------
def Joukowski(nn, Q, ds1 = -0.2):
    # hardcoded analytical function
    
    X = npy.zeros([2*nn*Q,2])
    a = 0.1

    # The Joukowski airfoil is already defined in a cosine parametric space,
    # so linspace is correct here, not cos(linspace).
    #s = 1-npy.linspace(0,1,nn+1)
    #print nn, s

    #Use a cos curve to cluster at LE and TE. def Joukowski_wake_x must use the same function.
    #s = Cos(nn)
    
    #Use a Bezier curve to cluster at LE and TE. def Joukowski_wake_x must use the same function.
    s = Bezier(nn, ds1=ds1)
    
    #print nn, s
    sL = spaceqarc(s, a, Q)
    #print sL;
    sU = sL[::-1]

    xL, yL = Joukowski_xy(sL,a)
    xU, yU = Joukowski_xy(sU,a)
    yL = -yL
    #print xL;

    s = npy.append(sL,-sU[1:])
    
    X[:,0] = npy.append(xL,xU[1:-1])
    X[:,1] = npy.append(yL,yU[1:-1])

    return X, sL

#===============================================================================
def spaceq(re, Q):
    nsub = Q
    nre = len(re) - 1
    nr  = nsub*nre
    r = npy.zeros(nr+1)
    for i in xrange(nre):
        for j in xrange(nsub):
            f = j/nsub
            r[i*nsub+j] = re[i]*(1.0-f) + re[i+1]*f
    r[nr] = re[nre]
    
    return r

#===============================================================================
def spaceqarc(se, a, Q):
    
    def arc(s):
        dxds, dyds = Joukowski_dxy_ds(s,a)
        return npy.sqrt( dxds**2 + dyds**2 )

    nsub = Q
    ns = len(se) - 1
    nr  = nsub*ns
    s = npy.zeros(nr+1)
    for i in xrange(ns):
        
        arclength = integrate.quad( arc, se[i], se[i+1] )[0]
        
        s[i*nsub] = se[i]
        for j in xrange(1,nsub):
            f = j/float(nsub)
            
            s[i*nsub+j] = optimize.bisect(lambda t:integrate.quad( arc, se[i], t )[0]-arclength*f, se[i] + 1e-8*arclength, se[i+1]-1e-8*arclength)

    s[nr] = se[ns]
    
    return s



if __name__ == '__main__':
    #nnormal = 16
    #reynolds = 1e3
    #maxref = 6
    #dy_te = 0.1 / reynolds**0.5 / 2**maxref
    #print nnormal*2**maxref, dy_te
    
    Q = 1
    for ref in xrange(0,1):
        make_airfoil(ref, Q, True,'msh', reynolds=1.e6,
                     filename_base="Joukowski")
        print("Done with level " + str(ref));
    #import pylab as pyl
    #X = Joukowski(500, 1)
    #pyl.plot(X[:,0],X[:,1],'-o')
    #pyl.axis( [0,1,-0.5,0.5] )
    #pyl.show()
